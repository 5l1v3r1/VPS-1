// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ssa_export.proto

#ifndef PROTOBUF_ssa_5fexport_2eproto__INCLUDED
#define PROTOBUF_ssa_5fexport_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ssa {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_ssa_5fexport_2eproto();
void protobuf_AssignDesc_ssa_5fexport_2eproto();
void protobuf_ShutdownFile_ssa_5fexport_2eproto();

class AddressTricore;
class AddressX64;
class BaseInstruction;
class BasicBlock;
class BitTricore;
class CallingConvention;
class Constant;
class ConstantTricore;
class ConstantX64;
class Function;
class Functions;
class Instruction;
class Memory;
class MemoryTricore;
class MemoryX64;
class Operand;
class PhiNode;
class Register;
class RegisterTricore;
class RegisterX64;

enum AccessType {
  UNKNOWN = 0,
  READ = 1,
  WRITE = 2,
  READWRITE = 3,
  AccessType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AccessType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AccessType_IsValid(int value);
const AccessType AccessType_MIN = UNKNOWN;
const AccessType AccessType_MAX = READWRITE;
const int AccessType_ARRAYSIZE = AccessType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccessType_descriptor();
inline const ::std::string& AccessType_Name(AccessType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccessType_descriptor(), value);
}
inline bool AccessType_Parse(
    const ::std::string& name, AccessType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccessType>(
    AccessType_descriptor(), name, value);
}
// ===================================================================

class RegisterX64 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.RegisterX64) */ {
 public:
  RegisterX64();
  virtual ~RegisterX64();

  RegisterX64(const RegisterX64& from);

  inline RegisterX64& operator=(const RegisterX64& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterX64& default_instance();

  void Swap(RegisterX64* other);

  // implements Message ----------------------------------------------

  inline RegisterX64* New() const { return New(NULL); }

  RegisterX64* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterX64& from);
  void MergeFrom(const RegisterX64& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterX64* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // optional sfixed32 phi_index = 2;
  void clear_phi_index();
  static const int kPhiIndexFieldNumber = 2;
  ::google::protobuf::int32 phi_index() const;
  void set_phi_index(::google::protobuf::int32 value);

  // optional .ssa.AccessType access_type = 3;
  void clear_access_type();
  static const int kAccessTypeFieldNumber = 3;
  ::ssa::AccessType access_type() const;
  void set_access_type(::ssa::AccessType value);

  // @@protoc_insertion_point(class_scope:ssa.RegisterX64)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::int32 phi_index_;
  int access_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static RegisterX64* default_instance_;
};
// -------------------------------------------------------------------

class RegisterTricore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.RegisterTricore) */ {
 public:
  RegisterTricore();
  virtual ~RegisterTricore();

  RegisterTricore(const RegisterTricore& from);

  inline RegisterTricore& operator=(const RegisterTricore& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterTricore& default_instance();

  void Swap(RegisterTricore* other);

  // implements Message ----------------------------------------------

  inline RegisterTricore* New() const { return New(NULL); }

  RegisterTricore* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterTricore& from);
  void MergeFrom(const RegisterTricore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterTricore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // optional sfixed32 phi_index = 2;
  void clear_phi_index();
  static const int kPhiIndexFieldNumber = 2;
  ::google::protobuf::int32 phi_index() const;
  void set_phi_index(::google::protobuf::int32 value);

  // optional .ssa.AccessType access_type = 3;
  void clear_access_type();
  static const int kAccessTypeFieldNumber = 3;
  ::ssa::AccessType access_type() const;
  void set_access_type(::ssa::AccessType value);

  // @@protoc_insertion_point(class_scope:ssa.RegisterTricore)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::int32 phi_index_;
  int access_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static RegisterTricore* default_instance_;
};
// -------------------------------------------------------------------

class BitTricore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.BitTricore) */ {
 public:
  BitTricore();
  virtual ~BitTricore();

  BitTricore(const BitTricore& from);

  inline BitTricore& operator=(const BitTricore& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BitTricore& default_instance();

  void Swap(BitTricore* other);

  // implements Message ----------------------------------------------

  inline BitTricore* New() const { return New(NULL); }

  BitTricore* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BitTricore& from);
  void MergeFrom(const BitTricore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BitTricore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // optional sfixed32 phi_index = 2;
  void clear_phi_index();
  static const int kPhiIndexFieldNumber = 2;
  ::google::protobuf::int32 phi_index() const;
  void set_phi_index(::google::protobuf::int32 value);

  // optional .ssa.AccessType access_type = 3;
  void clear_access_type();
  static const int kAccessTypeFieldNumber = 3;
  ::ssa::AccessType access_type() const;
  void set_access_type(::ssa::AccessType value);

  // @@protoc_insertion_point(class_scope:ssa.BitTricore)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::int32 phi_index_;
  int access_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static BitTricore* default_instance_;
};
// -------------------------------------------------------------------

class Register : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.Register) */ {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Register& default_instance();

  enum ContentCase {
    kRegisterX64 = 1,
    kRegisterTricore = 2,
    kBitTricore = 3,
    CONTENT_NOT_SET = 0,
  };

  void Swap(Register* other);

  // implements Message ----------------------------------------------

  inline Register* New() const { return New(NULL); }

  Register* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Register* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssa.RegisterX64 register_x64 = 1;
  bool has_register_x64() const;
  void clear_register_x64();
  static const int kRegisterX64FieldNumber = 1;
  const ::ssa::RegisterX64& register_x64() const;
  ::ssa::RegisterX64* mutable_register_x64();
  ::ssa::RegisterX64* release_register_x64();
  void set_allocated_register_x64(::ssa::RegisterX64* register_x64);

  // optional .ssa.RegisterTricore register_tricore = 2;
  bool has_register_tricore() const;
  void clear_register_tricore();
  static const int kRegisterTricoreFieldNumber = 2;
  const ::ssa::RegisterTricore& register_tricore() const;
  ::ssa::RegisterTricore* mutable_register_tricore();
  ::ssa::RegisterTricore* release_register_tricore();
  void set_allocated_register_tricore(::ssa::RegisterTricore* register_tricore);

  // optional .ssa.BitTricore bit_tricore = 3;
  bool has_bit_tricore() const;
  void clear_bit_tricore();
  static const int kBitTricoreFieldNumber = 3;
  const ::ssa::BitTricore& bit_tricore() const;
  ::ssa::BitTricore* mutable_bit_tricore();
  ::ssa::BitTricore* release_bit_tricore();
  void set_allocated_bit_tricore(::ssa::BitTricore* bit_tricore);

  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:ssa.Register)
 private:
  inline void set_has_register_x64();
  inline void set_has_register_tricore();
  inline void set_has_bit_tricore();

  inline bool has_content() const;
  void clear_content();
  inline void clear_has_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ContentUnion {
    ContentUnion() {}
    ::ssa::RegisterX64* register_x64_;
    ::ssa::RegisterTricore* register_tricore_;
    ::ssa::BitTricore* bit_tricore_;
  } content_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static Register* default_instance_;
};
// -------------------------------------------------------------------

class ConstantX64 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.ConstantX64) */ {
 public:
  ConstantX64();
  virtual ~ConstantX64();

  ConstantX64(const ConstantX64& from);

  inline ConstantX64& operator=(const ConstantX64& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstantX64& default_instance();

  void Swap(ConstantX64* other);

  // implements Message ----------------------------------------------

  inline ConstantX64* New() const { return New(NULL); }

  ConstantX64* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConstantX64& from);
  void MergeFrom(const ConstantX64& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConstantX64* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int64 value() const;
  void set_value(::google::protobuf::int64 value);

  // optional .ssa.AccessType access_type = 2;
  void clear_access_type();
  static const int kAccessTypeFieldNumber = 2;
  ::ssa::AccessType access_type() const;
  void set_access_type(::ssa::AccessType value);

  // @@protoc_insertion_point(class_scope:ssa.ConstantX64)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 value_;
  int access_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static ConstantX64* default_instance_;
};
// -------------------------------------------------------------------

class AddressX64 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.AddressX64) */ {
 public:
  AddressX64();
  virtual ~AddressX64();

  AddressX64(const AddressX64& from);

  inline AddressX64& operator=(const AddressX64& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddressX64& default_instance();

  void Swap(AddressX64* other);

  // implements Message ----------------------------------------------

  inline AddressX64* New() const { return New(NULL); }

  AddressX64* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddressX64& from);
  void MergeFrom(const AddressX64& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AddressX64* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // optional .ssa.AccessType access_type = 2;
  void clear_access_type();
  static const int kAccessTypeFieldNumber = 2;
  ::ssa::AccessType access_type() const;
  void set_access_type(::ssa::AccessType value);

  // @@protoc_insertion_point(class_scope:ssa.AddressX64)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 value_;
  int access_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static AddressX64* default_instance_;
};
// -------------------------------------------------------------------

class ConstantTricore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.ConstantTricore) */ {
 public:
  ConstantTricore();
  virtual ~ConstantTricore();

  ConstantTricore(const ConstantTricore& from);

  inline ConstantTricore& operator=(const ConstantTricore& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstantTricore& default_instance();

  void Swap(ConstantTricore* other);

  // implements Message ----------------------------------------------

  inline ConstantTricore* New() const { return New(NULL); }

  ConstantTricore* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConstantTricore& from);
  void MergeFrom(const ConstantTricore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConstantTricore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // optional .ssa.AccessType access_type = 2;
  void clear_access_type();
  static const int kAccessTypeFieldNumber = 2;
  ::ssa::AccessType access_type() const;
  void set_access_type(::ssa::AccessType value);

  // @@protoc_insertion_point(class_scope:ssa.ConstantTricore)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 value_;
  int access_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static ConstantTricore* default_instance_;
};
// -------------------------------------------------------------------

class AddressTricore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.AddressTricore) */ {
 public:
  AddressTricore();
  virtual ~AddressTricore();

  AddressTricore(const AddressTricore& from);

  inline AddressTricore& operator=(const AddressTricore& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddressTricore& default_instance();

  void Swap(AddressTricore* other);

  // implements Message ----------------------------------------------

  inline AddressTricore* New() const { return New(NULL); }

  AddressTricore* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddressTricore& from);
  void MergeFrom(const AddressTricore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AddressTricore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // optional .ssa.AccessType access_type = 2;
  void clear_access_type();
  static const int kAccessTypeFieldNumber = 2;
  ::ssa::AccessType access_type() const;
  void set_access_type(::ssa::AccessType value);

  // @@protoc_insertion_point(class_scope:ssa.AddressTricore)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 value_;
  int access_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static AddressTricore* default_instance_;
};
// -------------------------------------------------------------------

class Constant : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.Constant) */ {
 public:
  Constant();
  virtual ~Constant();

  Constant(const Constant& from);

  inline Constant& operator=(const Constant& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Constant& default_instance();

  enum ContentCase {
    kConstantX64 = 1,
    kConstantTricore = 2,
    kAddressTricore = 3,
    kAddressX64 = 4,
    CONTENT_NOT_SET = 0,
  };

  void Swap(Constant* other);

  // implements Message ----------------------------------------------

  inline Constant* New() const { return New(NULL); }

  Constant* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Constant& from);
  void MergeFrom(const Constant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Constant* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssa.ConstantX64 constant_x64 = 1;
  bool has_constant_x64() const;
  void clear_constant_x64();
  static const int kConstantX64FieldNumber = 1;
  const ::ssa::ConstantX64& constant_x64() const;
  ::ssa::ConstantX64* mutable_constant_x64();
  ::ssa::ConstantX64* release_constant_x64();
  void set_allocated_constant_x64(::ssa::ConstantX64* constant_x64);

  // optional .ssa.ConstantTricore constant_tricore = 2;
  bool has_constant_tricore() const;
  void clear_constant_tricore();
  static const int kConstantTricoreFieldNumber = 2;
  const ::ssa::ConstantTricore& constant_tricore() const;
  ::ssa::ConstantTricore* mutable_constant_tricore();
  ::ssa::ConstantTricore* release_constant_tricore();
  void set_allocated_constant_tricore(::ssa::ConstantTricore* constant_tricore);

  // optional .ssa.AddressTricore address_tricore = 3;
  bool has_address_tricore() const;
  void clear_address_tricore();
  static const int kAddressTricoreFieldNumber = 3;
  const ::ssa::AddressTricore& address_tricore() const;
  ::ssa::AddressTricore* mutable_address_tricore();
  ::ssa::AddressTricore* release_address_tricore();
  void set_allocated_address_tricore(::ssa::AddressTricore* address_tricore);

  // optional .ssa.AddressX64 address_x64 = 4;
  bool has_address_x64() const;
  void clear_address_x64();
  static const int kAddressX64FieldNumber = 4;
  const ::ssa::AddressX64& address_x64() const;
  ::ssa::AddressX64* mutable_address_x64();
  ::ssa::AddressX64* release_address_x64();
  void set_allocated_address_x64(::ssa::AddressX64* address_x64);

  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:ssa.Constant)
 private:
  inline void set_has_constant_x64();
  inline void set_has_constant_tricore();
  inline void set_has_address_tricore();
  inline void set_has_address_x64();

  inline bool has_content() const;
  void clear_content();
  inline void clear_has_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ContentUnion {
    ContentUnion() {}
    ::ssa::ConstantX64* constant_x64_;
    ::ssa::ConstantTricore* constant_tricore_;
    ::ssa::AddressTricore* address_tricore_;
    ::ssa::AddressX64* address_x64_;
  } content_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static Constant* default_instance_;
};
// -------------------------------------------------------------------

class MemoryX64 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.MemoryX64) */ {
 public:
  MemoryX64();
  virtual ~MemoryX64();

  MemoryX64(const MemoryX64& from);

  inline MemoryX64& operator=(const MemoryX64& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemoryX64& default_instance();

  void Swap(MemoryX64* other);

  // implements Message ----------------------------------------------

  inline MemoryX64* New() const { return New(NULL); }

  MemoryX64* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemoryX64& from);
  void MergeFrom(const MemoryX64& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MemoryX64* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssa.Register base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  const ::ssa::Register& base() const;
  ::ssa::Register* mutable_base();
  ::ssa::Register* release_base();
  void set_allocated_base(::ssa::Register* base);

  // optional .ssa.Constant offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  const ::ssa::Constant& offset() const;
  ::ssa::Constant* mutable_offset();
  ::ssa::Constant* release_offset();
  void set_allocated_offset(::ssa::Constant* offset);

  // optional .ssa.AccessType access_type = 3;
  void clear_access_type();
  static const int kAccessTypeFieldNumber = 3;
  ::ssa::AccessType access_type() const;
  void set_access_type(::ssa::AccessType value);

  // optional .ssa.Register index = 4;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 4;
  const ::ssa::Register& index() const;
  ::ssa::Register* mutable_index();
  ::ssa::Register* release_index();
  void set_allocated_index(::ssa::Register* index);

  // optional .ssa.Constant index_factor = 5;
  bool has_index_factor() const;
  void clear_index_factor();
  static const int kIndexFactorFieldNumber = 5;
  const ::ssa::Constant& index_factor() const;
  ::ssa::Constant* mutable_index_factor();
  ::ssa::Constant* release_index_factor();
  void set_allocated_index_factor(::ssa::Constant* index_factor);

  // @@protoc_insertion_point(class_scope:ssa.MemoryX64)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::ssa::Register* base_;
  ::ssa::Constant* offset_;
  ::ssa::Register* index_;
  ::ssa::Constant* index_factor_;
  int access_type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static MemoryX64* default_instance_;
};
// -------------------------------------------------------------------

class MemoryTricore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.MemoryTricore) */ {
 public:
  MemoryTricore();
  virtual ~MemoryTricore();

  MemoryTricore(const MemoryTricore& from);

  inline MemoryTricore& operator=(const MemoryTricore& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemoryTricore& default_instance();

  void Swap(MemoryTricore* other);

  // implements Message ----------------------------------------------

  inline MemoryTricore* New() const { return New(NULL); }

  MemoryTricore* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemoryTricore& from);
  void MergeFrom(const MemoryTricore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MemoryTricore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssa.Register base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  const ::ssa::Register& base() const;
  ::ssa::Register* mutable_base();
  ::ssa::Register* release_base();
  void set_allocated_base(::ssa::Register* base);

  // optional .ssa.Constant offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  const ::ssa::Constant& offset() const;
  ::ssa::Constant* mutable_offset();
  ::ssa::Constant* release_offset();
  void set_allocated_offset(::ssa::Constant* offset);

  // optional .ssa.AccessType access_type = 3;
  void clear_access_type();
  static const int kAccessTypeFieldNumber = 3;
  ::ssa::AccessType access_type() const;
  void set_access_type(::ssa::AccessType value);

  // optional bool pre_increment = 4;
  void clear_pre_increment();
  static const int kPreIncrementFieldNumber = 4;
  bool pre_increment() const;
  void set_pre_increment(bool value);

  // optional bool post_increment = 5;
  void clear_post_increment();
  static const int kPostIncrementFieldNumber = 5;
  bool post_increment() const;
  void set_post_increment(bool value);

  // @@protoc_insertion_point(class_scope:ssa.MemoryTricore)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::ssa::Register* base_;
  ::ssa::Constant* offset_;
  int access_type_;
  bool pre_increment_;
  bool post_increment_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static MemoryTricore* default_instance_;
};
// -------------------------------------------------------------------

class Memory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.Memory) */ {
 public:
  Memory();
  virtual ~Memory();

  Memory(const Memory& from);

  inline Memory& operator=(const Memory& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Memory& default_instance();

  enum ContentCase {
    kMemoryX64 = 1,
    kMemoryTricore = 2,
    CONTENT_NOT_SET = 0,
  };

  void Swap(Memory* other);

  // implements Message ----------------------------------------------

  inline Memory* New() const { return New(NULL); }

  Memory* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Memory& from);
  void MergeFrom(const Memory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Memory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssa.MemoryX64 memory_x64 = 1;
  bool has_memory_x64() const;
  void clear_memory_x64();
  static const int kMemoryX64FieldNumber = 1;
  const ::ssa::MemoryX64& memory_x64() const;
  ::ssa::MemoryX64* mutable_memory_x64();
  ::ssa::MemoryX64* release_memory_x64();
  void set_allocated_memory_x64(::ssa::MemoryX64* memory_x64);

  // optional .ssa.MemoryTricore memory_tricore = 2;
  bool has_memory_tricore() const;
  void clear_memory_tricore();
  static const int kMemoryTricoreFieldNumber = 2;
  const ::ssa::MemoryTricore& memory_tricore() const;
  ::ssa::MemoryTricore* mutable_memory_tricore();
  ::ssa::MemoryTricore* release_memory_tricore();
  void set_allocated_memory_tricore(::ssa::MemoryTricore* memory_tricore);

  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:ssa.Memory)
 private:
  inline void set_has_memory_x64();
  inline void set_has_memory_tricore();

  inline bool has_content() const;
  void clear_content();
  inline void clear_has_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ContentUnion {
    ContentUnion() {}
    ::ssa::MemoryX64* memory_x64_;
    ::ssa::MemoryTricore* memory_tricore_;
  } content_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static Memory* default_instance_;
};
// -------------------------------------------------------------------

class CallingConvention : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.CallingConvention) */ {
 public:
  CallingConvention();
  virtual ~CallingConvention();

  CallingConvention(const CallingConvention& from);

  inline CallingConvention& operator=(const CallingConvention& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CallingConvention& default_instance();

  void Swap(CallingConvention* other);

  // implements Message ----------------------------------------------

  inline CallingConvention* New() const { return New(NULL); }

  CallingConvention* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CallingConvention& from);
  void MergeFrom(const CallingConvention& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CallingConvention* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::google::protobuf::uint64 address() const;
  void set_address(::google::protobuf::uint64 value);

  // optional string mnemonic = 2;
  void clear_mnemonic();
  static const int kMnemonicFieldNumber = 2;
  const ::std::string& mnemonic() const;
  void set_mnemonic(const ::std::string& value);
  void set_mnemonic(const char* value);
  void set_mnemonic(const char* value, size_t size);
  ::std::string* mutable_mnemonic();
  ::std::string* release_mnemonic();
  void set_allocated_mnemonic(::std::string* mnemonic);

  // repeated .ssa.Operand operands = 3;
  int operands_size() const;
  void clear_operands();
  static const int kOperandsFieldNumber = 3;
  const ::ssa::Operand& operands(int index) const;
  ::ssa::Operand* mutable_operands(int index);
  ::ssa::Operand* add_operands();
  ::google::protobuf::RepeatedPtrField< ::ssa::Operand >*
      mutable_operands();
  const ::google::protobuf::RepeatedPtrField< ::ssa::Operand >&
      operands() const;

  // @@protoc_insertion_point(class_scope:ssa.CallingConvention)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 address_;
  ::google::protobuf::internal::ArenaStringPtr mnemonic_;
  ::google::protobuf::RepeatedPtrField< ::ssa::Operand > operands_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static CallingConvention* default_instance_;
};
// -------------------------------------------------------------------

class BaseInstruction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.BaseInstruction) */ {
 public:
  BaseInstruction();
  virtual ~BaseInstruction();

  BaseInstruction(const BaseInstruction& from);

  inline BaseInstruction& operator=(const BaseInstruction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseInstruction& default_instance();

  void Swap(BaseInstruction* other);

  // implements Message ----------------------------------------------

  inline BaseInstruction* New() const { return New(NULL); }

  BaseInstruction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseInstruction& from);
  void MergeFrom(const BaseInstruction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BaseInstruction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::google::protobuf::uint64 address() const;
  void set_address(::google::protobuf::uint64 value);

  // optional string mnemonic = 2;
  void clear_mnemonic();
  static const int kMnemonicFieldNumber = 2;
  const ::std::string& mnemonic() const;
  void set_mnemonic(const ::std::string& value);
  void set_mnemonic(const char* value);
  void set_mnemonic(const char* value, size_t size);
  ::std::string* mutable_mnemonic();
  ::std::string* release_mnemonic();
  void set_allocated_mnemonic(::std::string* mnemonic);

  // repeated .ssa.Operand operands = 3;
  int operands_size() const;
  void clear_operands();
  static const int kOperandsFieldNumber = 3;
  const ::ssa::Operand& operands(int index) const;
  ::ssa::Operand* mutable_operands(int index);
  ::ssa::Operand* add_operands();
  ::google::protobuf::RepeatedPtrField< ::ssa::Operand >*
      mutable_operands();
  const ::google::protobuf::RepeatedPtrField< ::ssa::Operand >&
      operands() const;

  // @@protoc_insertion_point(class_scope:ssa.BaseInstruction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 address_;
  ::google::protobuf::internal::ArenaStringPtr mnemonic_;
  ::google::protobuf::RepeatedPtrField< ::ssa::Operand > operands_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static BaseInstruction* default_instance_;
};
// -------------------------------------------------------------------

class PhiNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.PhiNode) */ {
 public:
  PhiNode();
  virtual ~PhiNode();

  PhiNode(const PhiNode& from);

  inline PhiNode& operator=(const PhiNode& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PhiNode& default_instance();

  void Swap(PhiNode* other);

  // implements Message ----------------------------------------------

  inline PhiNode* New() const { return New(NULL); }

  PhiNode* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PhiNode& from);
  void MergeFrom(const PhiNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PhiNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::google::protobuf::uint64 address() const;
  void set_address(::google::protobuf::uint64 value);

  // optional string mnemonic = 2;
  void clear_mnemonic();
  static const int kMnemonicFieldNumber = 2;
  const ::std::string& mnemonic() const;
  void set_mnemonic(const ::std::string& value);
  void set_mnemonic(const char* value);
  void set_mnemonic(const char* value, size_t size);
  ::std::string* mutable_mnemonic();
  ::std::string* release_mnemonic();
  void set_allocated_mnemonic(::std::string* mnemonic);

  // repeated .ssa.Operand operands = 3;
  int operands_size() const;
  void clear_operands();
  static const int kOperandsFieldNumber = 3;
  const ::ssa::Operand& operands(int index) const;
  ::ssa::Operand* mutable_operands(int index);
  ::ssa::Operand* add_operands();
  ::google::protobuf::RepeatedPtrField< ::ssa::Operand >*
      mutable_operands();
  const ::google::protobuf::RepeatedPtrField< ::ssa::Operand >&
      operands() const;

  // @@protoc_insertion_point(class_scope:ssa.PhiNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 address_;
  ::google::protobuf::internal::ArenaStringPtr mnemonic_;
  ::google::protobuf::RepeatedPtrField< ::ssa::Operand > operands_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static PhiNode* default_instance_;
};
// -------------------------------------------------------------------

class Operand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.Operand) */ {
 public:
  Operand();
  virtual ~Operand();

  Operand(const Operand& from);

  inline Operand& operator=(const Operand& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Operand& default_instance();

  enum ContentCase {
    kRegister = 1,
    kConstant = 2,
    kMemory = 3,
    CONTENT_NOT_SET = 0,
  };

  void Swap(Operand* other);

  // implements Message ----------------------------------------------

  inline Operand* New() const { return New(NULL); }

  Operand* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operand& from);
  void MergeFrom(const Operand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Operand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssa.Register register = 1;
  bool has_register_() const;
  void clear_register_();
  static const int kRegisterFieldNumber = 1;
  const ::ssa::Register& register_() const;
  ::ssa::Register* mutable_register_();
  ::ssa::Register* release_register_();
  void set_allocated_register_(::ssa::Register* register_);

  // optional .ssa.Constant constant = 2;
  bool has_constant() const;
  void clear_constant();
  static const int kConstantFieldNumber = 2;
  const ::ssa::Constant& constant() const;
  ::ssa::Constant* mutable_constant();
  ::ssa::Constant* release_constant();
  void set_allocated_constant(::ssa::Constant* constant);

  // optional .ssa.Memory memory = 3;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 3;
  const ::ssa::Memory& memory() const;
  ::ssa::Memory* mutable_memory();
  ::ssa::Memory* release_memory();
  void set_allocated_memory(::ssa::Memory* memory);

  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:ssa.Operand)
 private:
  inline void set_has_register_();
  inline void set_has_constant();
  inline void set_has_memory();

  inline bool has_content() const;
  void clear_content();
  inline void clear_has_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ContentUnion {
    ContentUnion() {}
    ::ssa::Register* register__;
    ::ssa::Constant* constant_;
    ::ssa::Memory* memory_;
  } content_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static Operand* default_instance_;
};
// -------------------------------------------------------------------

class Instruction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.Instruction) */ {
 public:
  Instruction();
  virtual ~Instruction();

  Instruction(const Instruction& from);

  inline Instruction& operator=(const Instruction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Instruction& default_instance();

  enum ContentCase {
    kCallingConvention = 1,
    kInstruction = 2,
    kPhiNode = 3,
    CONTENT_NOT_SET = 0,
  };

  void Swap(Instruction* other);

  // implements Message ----------------------------------------------

  inline Instruction* New() const { return New(NULL); }

  Instruction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Instruction& from);
  void MergeFrom(const Instruction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Instruction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssa.CallingConvention calling_convention = 1;
  bool has_calling_convention() const;
  void clear_calling_convention();
  static const int kCallingConventionFieldNumber = 1;
  const ::ssa::CallingConvention& calling_convention() const;
  ::ssa::CallingConvention* mutable_calling_convention();
  ::ssa::CallingConvention* release_calling_convention();
  void set_allocated_calling_convention(::ssa::CallingConvention* calling_convention);

  // optional .ssa.BaseInstruction instruction = 2;
  bool has_instruction() const;
  void clear_instruction();
  static const int kInstructionFieldNumber = 2;
  const ::ssa::BaseInstruction& instruction() const;
  ::ssa::BaseInstruction* mutable_instruction();
  ::ssa::BaseInstruction* release_instruction();
  void set_allocated_instruction(::ssa::BaseInstruction* instruction);

  // optional .ssa.PhiNode phi_node = 3;
  bool has_phi_node() const;
  void clear_phi_node();
  static const int kPhiNodeFieldNumber = 3;
  const ::ssa::PhiNode& phi_node() const;
  ::ssa::PhiNode* mutable_phi_node();
  ::ssa::PhiNode* release_phi_node();
  void set_allocated_phi_node(::ssa::PhiNode* phi_node);

  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:ssa.Instruction)
 private:
  inline void set_has_calling_convention();
  inline void set_has_instruction();
  inline void set_has_phi_node();

  inline bool has_content() const;
  void clear_content();
  inline void clear_has_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ContentUnion {
    ContentUnion() {}
    ::ssa::CallingConvention* calling_convention_;
    ::ssa::BaseInstruction* instruction_;
    ::ssa::PhiNode* phi_node_;
  } content_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static Instruction* default_instance_;
};
// -------------------------------------------------------------------

class BasicBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.BasicBlock) */ {
 public:
  BasicBlock();
  virtual ~BasicBlock();

  BasicBlock(const BasicBlock& from);

  inline BasicBlock& operator=(const BasicBlock& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BasicBlock& default_instance();

  void Swap(BasicBlock* other);

  // implements Message ----------------------------------------------

  inline BasicBlock* New() const { return New(NULL); }

  BasicBlock* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BasicBlock& from);
  void MergeFrom(const BasicBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BasicBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::google::protobuf::uint64 address() const;
  void set_address(::google::protobuf::uint64 value);

  // optional fixed64 end = 2;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::uint64 end() const;
  void set_end(::google::protobuf::uint64 value);

  // repeated .ssa.Instruction instructions = 3;
  int instructions_size() const;
  void clear_instructions();
  static const int kInstructionsFieldNumber = 3;
  const ::ssa::Instruction& instructions(int index) const;
  ::ssa::Instruction* mutable_instructions(int index);
  ::ssa::Instruction* add_instructions();
  ::google::protobuf::RepeatedPtrField< ::ssa::Instruction >*
      mutable_instructions();
  const ::google::protobuf::RepeatedPtrField< ::ssa::Instruction >&
      instructions() const;

  // repeated fixed64 predecessors = 4;
  int predecessors_size() const;
  void clear_predecessors();
  static const int kPredecessorsFieldNumber = 4;
  ::google::protobuf::uint64 predecessors(int index) const;
  void set_predecessors(int index, ::google::protobuf::uint64 value);
  void add_predecessors(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      predecessors() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_predecessors();

  // repeated fixed64 successors = 5;
  int successors_size() const;
  void clear_successors();
  static const int kSuccessorsFieldNumber = 5;
  ::google::protobuf::uint64 successors(int index) const;
  void set_successors(int index, ::google::protobuf::uint64 value);
  void add_successors(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      successors() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_successors();

  // @@protoc_insertion_point(class_scope:ssa.BasicBlock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 address_;
  ::google::protobuf::uint64 end_;
  ::google::protobuf::RepeatedPtrField< ::ssa::Instruction > instructions_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > predecessors_;
  mutable int _predecessors_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > successors_;
  mutable int _successors_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static BasicBlock* default_instance_;
};
// -------------------------------------------------------------------

class Function : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.Function) */ {
 public:
  Function();
  virtual ~Function();

  Function(const Function& from);

  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Function& default_instance();

  void Swap(Function* other);

  // implements Message ----------------------------------------------

  inline Function* New() const { return New(NULL); }

  Function* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Function& from);
  void MergeFrom(const Function& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Function* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::google::protobuf::uint64 address() const;
  void set_address(::google::protobuf::uint64 value);

  // repeated .ssa.BasicBlock basic_blocks = 2;
  int basic_blocks_size() const;
  void clear_basic_blocks();
  static const int kBasicBlocksFieldNumber = 2;
  const ::ssa::BasicBlock& basic_blocks(int index) const;
  ::ssa::BasicBlock* mutable_basic_blocks(int index);
  ::ssa::BasicBlock* add_basic_blocks();
  ::google::protobuf::RepeatedPtrField< ::ssa::BasicBlock >*
      mutable_basic_blocks();
  const ::google::protobuf::RepeatedPtrField< ::ssa::BasicBlock >&
      basic_blocks() const;

  // @@protoc_insertion_point(class_scope:ssa.Function)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 address_;
  ::google::protobuf::RepeatedPtrField< ::ssa::BasicBlock > basic_blocks_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static Function* default_instance_;
};
// -------------------------------------------------------------------

class Functions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssa.Functions) */ {
 public:
  Functions();
  virtual ~Functions();

  Functions(const Functions& from);

  inline Functions& operator=(const Functions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Functions& default_instance();

  void Swap(Functions* other);

  // implements Message ----------------------------------------------

  inline Functions* New() const { return New(NULL); }

  Functions* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Functions& from);
  void MergeFrom(const Functions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Functions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ssa.Function functions = 1;
  int functions_size() const;
  void clear_functions();
  static const int kFunctionsFieldNumber = 1;
  const ::ssa::Function& functions(int index) const;
  ::ssa::Function* mutable_functions(int index);
  ::ssa::Function* add_functions();
  ::google::protobuf::RepeatedPtrField< ::ssa::Function >*
      mutable_functions();
  const ::google::protobuf::RepeatedPtrField< ::ssa::Function >&
      functions() const;

  // @@protoc_insertion_point(class_scope:ssa.Functions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::ssa::Function > functions_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ssa_5fexport_2eproto();
  friend void protobuf_AssignDesc_ssa_5fexport_2eproto();
  friend void protobuf_ShutdownFile_ssa_5fexport_2eproto();

  void InitAsDefaultInstance();
  static Functions* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterX64

// optional fixed32 index = 1;
inline void RegisterX64::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 RegisterX64::index() const {
  // @@protoc_insertion_point(field_get:ssa.RegisterX64.index)
  return index_;
}
inline void RegisterX64::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:ssa.RegisterX64.index)
}

// optional sfixed32 phi_index = 2;
inline void RegisterX64::clear_phi_index() {
  phi_index_ = 0;
}
inline ::google::protobuf::int32 RegisterX64::phi_index() const {
  // @@protoc_insertion_point(field_get:ssa.RegisterX64.phi_index)
  return phi_index_;
}
inline void RegisterX64::set_phi_index(::google::protobuf::int32 value) {
  
  phi_index_ = value;
  // @@protoc_insertion_point(field_set:ssa.RegisterX64.phi_index)
}

// optional .ssa.AccessType access_type = 3;
inline void RegisterX64::clear_access_type() {
  access_type_ = 0;
}
inline ::ssa::AccessType RegisterX64::access_type() const {
  // @@protoc_insertion_point(field_get:ssa.RegisterX64.access_type)
  return static_cast< ::ssa::AccessType >(access_type_);
}
inline void RegisterX64::set_access_type(::ssa::AccessType value) {
  
  access_type_ = value;
  // @@protoc_insertion_point(field_set:ssa.RegisterX64.access_type)
}

// -------------------------------------------------------------------

// RegisterTricore

// optional fixed32 index = 1;
inline void RegisterTricore::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 RegisterTricore::index() const {
  // @@protoc_insertion_point(field_get:ssa.RegisterTricore.index)
  return index_;
}
inline void RegisterTricore::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:ssa.RegisterTricore.index)
}

// optional sfixed32 phi_index = 2;
inline void RegisterTricore::clear_phi_index() {
  phi_index_ = 0;
}
inline ::google::protobuf::int32 RegisterTricore::phi_index() const {
  // @@protoc_insertion_point(field_get:ssa.RegisterTricore.phi_index)
  return phi_index_;
}
inline void RegisterTricore::set_phi_index(::google::protobuf::int32 value) {
  
  phi_index_ = value;
  // @@protoc_insertion_point(field_set:ssa.RegisterTricore.phi_index)
}

// optional .ssa.AccessType access_type = 3;
inline void RegisterTricore::clear_access_type() {
  access_type_ = 0;
}
inline ::ssa::AccessType RegisterTricore::access_type() const {
  // @@protoc_insertion_point(field_get:ssa.RegisterTricore.access_type)
  return static_cast< ::ssa::AccessType >(access_type_);
}
inline void RegisterTricore::set_access_type(::ssa::AccessType value) {
  
  access_type_ = value;
  // @@protoc_insertion_point(field_set:ssa.RegisterTricore.access_type)
}

// -------------------------------------------------------------------

// BitTricore

// optional fixed32 index = 1;
inline void BitTricore::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 BitTricore::index() const {
  // @@protoc_insertion_point(field_get:ssa.BitTricore.index)
  return index_;
}
inline void BitTricore::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:ssa.BitTricore.index)
}

// optional sfixed32 phi_index = 2;
inline void BitTricore::clear_phi_index() {
  phi_index_ = 0;
}
inline ::google::protobuf::int32 BitTricore::phi_index() const {
  // @@protoc_insertion_point(field_get:ssa.BitTricore.phi_index)
  return phi_index_;
}
inline void BitTricore::set_phi_index(::google::protobuf::int32 value) {
  
  phi_index_ = value;
  // @@protoc_insertion_point(field_set:ssa.BitTricore.phi_index)
}

// optional .ssa.AccessType access_type = 3;
inline void BitTricore::clear_access_type() {
  access_type_ = 0;
}
inline ::ssa::AccessType BitTricore::access_type() const {
  // @@protoc_insertion_point(field_get:ssa.BitTricore.access_type)
  return static_cast< ::ssa::AccessType >(access_type_);
}
inline void BitTricore::set_access_type(::ssa::AccessType value) {
  
  access_type_ = value;
  // @@protoc_insertion_point(field_set:ssa.BitTricore.access_type)
}

// -------------------------------------------------------------------

// Register

// optional .ssa.RegisterX64 register_x64 = 1;
inline bool Register::has_register_x64() const {
  return content_case() == kRegisterX64;
}
inline void Register::set_has_register_x64() {
  _oneof_case_[0] = kRegisterX64;
}
inline void Register::clear_register_x64() {
  if (has_register_x64()) {
    delete content_.register_x64_;
    clear_has_content();
  }
}
inline  const ::ssa::RegisterX64& Register::register_x64() const {
  // @@protoc_insertion_point(field_get:ssa.Register.register_x64)
  return has_register_x64()
      ? *content_.register_x64_
      : ::ssa::RegisterX64::default_instance();
}
inline ::ssa::RegisterX64* Register::mutable_register_x64() {
  if (!has_register_x64()) {
    clear_content();
    set_has_register_x64();
    content_.register_x64_ = new ::ssa::RegisterX64;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Register.register_x64)
  return content_.register_x64_;
}
inline ::ssa::RegisterX64* Register::release_register_x64() {
  // @@protoc_insertion_point(field_release:ssa.Register.register_x64)
  if (has_register_x64()) {
    clear_has_content();
    ::ssa::RegisterX64* temp = content_.register_x64_;
    content_.register_x64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Register::set_allocated_register_x64(::ssa::RegisterX64* register_x64) {
  clear_content();
  if (register_x64) {
    set_has_register_x64();
    content_.register_x64_ = register_x64;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Register.register_x64)
}

// optional .ssa.RegisterTricore register_tricore = 2;
inline bool Register::has_register_tricore() const {
  return content_case() == kRegisterTricore;
}
inline void Register::set_has_register_tricore() {
  _oneof_case_[0] = kRegisterTricore;
}
inline void Register::clear_register_tricore() {
  if (has_register_tricore()) {
    delete content_.register_tricore_;
    clear_has_content();
  }
}
inline  const ::ssa::RegisterTricore& Register::register_tricore() const {
  // @@protoc_insertion_point(field_get:ssa.Register.register_tricore)
  return has_register_tricore()
      ? *content_.register_tricore_
      : ::ssa::RegisterTricore::default_instance();
}
inline ::ssa::RegisterTricore* Register::mutable_register_tricore() {
  if (!has_register_tricore()) {
    clear_content();
    set_has_register_tricore();
    content_.register_tricore_ = new ::ssa::RegisterTricore;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Register.register_tricore)
  return content_.register_tricore_;
}
inline ::ssa::RegisterTricore* Register::release_register_tricore() {
  // @@protoc_insertion_point(field_release:ssa.Register.register_tricore)
  if (has_register_tricore()) {
    clear_has_content();
    ::ssa::RegisterTricore* temp = content_.register_tricore_;
    content_.register_tricore_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Register::set_allocated_register_tricore(::ssa::RegisterTricore* register_tricore) {
  clear_content();
  if (register_tricore) {
    set_has_register_tricore();
    content_.register_tricore_ = register_tricore;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Register.register_tricore)
}

// optional .ssa.BitTricore bit_tricore = 3;
inline bool Register::has_bit_tricore() const {
  return content_case() == kBitTricore;
}
inline void Register::set_has_bit_tricore() {
  _oneof_case_[0] = kBitTricore;
}
inline void Register::clear_bit_tricore() {
  if (has_bit_tricore()) {
    delete content_.bit_tricore_;
    clear_has_content();
  }
}
inline  const ::ssa::BitTricore& Register::bit_tricore() const {
  // @@protoc_insertion_point(field_get:ssa.Register.bit_tricore)
  return has_bit_tricore()
      ? *content_.bit_tricore_
      : ::ssa::BitTricore::default_instance();
}
inline ::ssa::BitTricore* Register::mutable_bit_tricore() {
  if (!has_bit_tricore()) {
    clear_content();
    set_has_bit_tricore();
    content_.bit_tricore_ = new ::ssa::BitTricore;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Register.bit_tricore)
  return content_.bit_tricore_;
}
inline ::ssa::BitTricore* Register::release_bit_tricore() {
  // @@protoc_insertion_point(field_release:ssa.Register.bit_tricore)
  if (has_bit_tricore()) {
    clear_has_content();
    ::ssa::BitTricore* temp = content_.bit_tricore_;
    content_.bit_tricore_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Register::set_allocated_bit_tricore(::ssa::BitTricore* bit_tricore) {
  clear_content();
  if (bit_tricore) {
    set_has_bit_tricore();
    content_.bit_tricore_ = bit_tricore;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Register.bit_tricore)
}

inline bool Register::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void Register::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline Register::ContentCase Register::content_case() const {
  return Register::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConstantX64

// optional sfixed64 value = 1;
inline void ConstantX64::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ConstantX64::value() const {
  // @@protoc_insertion_point(field_get:ssa.ConstantX64.value)
  return value_;
}
inline void ConstantX64::set_value(::google::protobuf::int64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:ssa.ConstantX64.value)
}

// optional .ssa.AccessType access_type = 2;
inline void ConstantX64::clear_access_type() {
  access_type_ = 0;
}
inline ::ssa::AccessType ConstantX64::access_type() const {
  // @@protoc_insertion_point(field_get:ssa.ConstantX64.access_type)
  return static_cast< ::ssa::AccessType >(access_type_);
}
inline void ConstantX64::set_access_type(::ssa::AccessType value) {
  
  access_type_ = value;
  // @@protoc_insertion_point(field_set:ssa.ConstantX64.access_type)
}

// -------------------------------------------------------------------

// AddressX64

// optional fixed64 value = 1;
inline void AddressX64::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AddressX64::value() const {
  // @@protoc_insertion_point(field_get:ssa.AddressX64.value)
  return value_;
}
inline void AddressX64::set_value(::google::protobuf::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:ssa.AddressX64.value)
}

// optional .ssa.AccessType access_type = 2;
inline void AddressX64::clear_access_type() {
  access_type_ = 0;
}
inline ::ssa::AccessType AddressX64::access_type() const {
  // @@protoc_insertion_point(field_get:ssa.AddressX64.access_type)
  return static_cast< ::ssa::AccessType >(access_type_);
}
inline void AddressX64::set_access_type(::ssa::AccessType value) {
  
  access_type_ = value;
  // @@protoc_insertion_point(field_set:ssa.AddressX64.access_type)
}

// -------------------------------------------------------------------

// ConstantTricore

// optional sfixed32 value = 1;
inline void ConstantTricore::clear_value() {
  value_ = 0;
}
inline ::google::protobuf::int32 ConstantTricore::value() const {
  // @@protoc_insertion_point(field_get:ssa.ConstantTricore.value)
  return value_;
}
inline void ConstantTricore::set_value(::google::protobuf::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:ssa.ConstantTricore.value)
}

// optional .ssa.AccessType access_type = 2;
inline void ConstantTricore::clear_access_type() {
  access_type_ = 0;
}
inline ::ssa::AccessType ConstantTricore::access_type() const {
  // @@protoc_insertion_point(field_get:ssa.ConstantTricore.access_type)
  return static_cast< ::ssa::AccessType >(access_type_);
}
inline void ConstantTricore::set_access_type(::ssa::AccessType value) {
  
  access_type_ = value;
  // @@protoc_insertion_point(field_set:ssa.ConstantTricore.access_type)
}

// -------------------------------------------------------------------

// AddressTricore

// optional fixed32 value = 1;
inline void AddressTricore::clear_value() {
  value_ = 0u;
}
inline ::google::protobuf::uint32 AddressTricore::value() const {
  // @@protoc_insertion_point(field_get:ssa.AddressTricore.value)
  return value_;
}
inline void AddressTricore::set_value(::google::protobuf::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:ssa.AddressTricore.value)
}

// optional .ssa.AccessType access_type = 2;
inline void AddressTricore::clear_access_type() {
  access_type_ = 0;
}
inline ::ssa::AccessType AddressTricore::access_type() const {
  // @@protoc_insertion_point(field_get:ssa.AddressTricore.access_type)
  return static_cast< ::ssa::AccessType >(access_type_);
}
inline void AddressTricore::set_access_type(::ssa::AccessType value) {
  
  access_type_ = value;
  // @@protoc_insertion_point(field_set:ssa.AddressTricore.access_type)
}

// -------------------------------------------------------------------

// Constant

// optional .ssa.ConstantX64 constant_x64 = 1;
inline bool Constant::has_constant_x64() const {
  return content_case() == kConstantX64;
}
inline void Constant::set_has_constant_x64() {
  _oneof_case_[0] = kConstantX64;
}
inline void Constant::clear_constant_x64() {
  if (has_constant_x64()) {
    delete content_.constant_x64_;
    clear_has_content();
  }
}
inline  const ::ssa::ConstantX64& Constant::constant_x64() const {
  // @@protoc_insertion_point(field_get:ssa.Constant.constant_x64)
  return has_constant_x64()
      ? *content_.constant_x64_
      : ::ssa::ConstantX64::default_instance();
}
inline ::ssa::ConstantX64* Constant::mutable_constant_x64() {
  if (!has_constant_x64()) {
    clear_content();
    set_has_constant_x64();
    content_.constant_x64_ = new ::ssa::ConstantX64;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Constant.constant_x64)
  return content_.constant_x64_;
}
inline ::ssa::ConstantX64* Constant::release_constant_x64() {
  // @@protoc_insertion_point(field_release:ssa.Constant.constant_x64)
  if (has_constant_x64()) {
    clear_has_content();
    ::ssa::ConstantX64* temp = content_.constant_x64_;
    content_.constant_x64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Constant::set_allocated_constant_x64(::ssa::ConstantX64* constant_x64) {
  clear_content();
  if (constant_x64) {
    set_has_constant_x64();
    content_.constant_x64_ = constant_x64;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Constant.constant_x64)
}

// optional .ssa.ConstantTricore constant_tricore = 2;
inline bool Constant::has_constant_tricore() const {
  return content_case() == kConstantTricore;
}
inline void Constant::set_has_constant_tricore() {
  _oneof_case_[0] = kConstantTricore;
}
inline void Constant::clear_constant_tricore() {
  if (has_constant_tricore()) {
    delete content_.constant_tricore_;
    clear_has_content();
  }
}
inline  const ::ssa::ConstantTricore& Constant::constant_tricore() const {
  // @@protoc_insertion_point(field_get:ssa.Constant.constant_tricore)
  return has_constant_tricore()
      ? *content_.constant_tricore_
      : ::ssa::ConstantTricore::default_instance();
}
inline ::ssa::ConstantTricore* Constant::mutable_constant_tricore() {
  if (!has_constant_tricore()) {
    clear_content();
    set_has_constant_tricore();
    content_.constant_tricore_ = new ::ssa::ConstantTricore;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Constant.constant_tricore)
  return content_.constant_tricore_;
}
inline ::ssa::ConstantTricore* Constant::release_constant_tricore() {
  // @@protoc_insertion_point(field_release:ssa.Constant.constant_tricore)
  if (has_constant_tricore()) {
    clear_has_content();
    ::ssa::ConstantTricore* temp = content_.constant_tricore_;
    content_.constant_tricore_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Constant::set_allocated_constant_tricore(::ssa::ConstantTricore* constant_tricore) {
  clear_content();
  if (constant_tricore) {
    set_has_constant_tricore();
    content_.constant_tricore_ = constant_tricore;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Constant.constant_tricore)
}

// optional .ssa.AddressTricore address_tricore = 3;
inline bool Constant::has_address_tricore() const {
  return content_case() == kAddressTricore;
}
inline void Constant::set_has_address_tricore() {
  _oneof_case_[0] = kAddressTricore;
}
inline void Constant::clear_address_tricore() {
  if (has_address_tricore()) {
    delete content_.address_tricore_;
    clear_has_content();
  }
}
inline  const ::ssa::AddressTricore& Constant::address_tricore() const {
  // @@protoc_insertion_point(field_get:ssa.Constant.address_tricore)
  return has_address_tricore()
      ? *content_.address_tricore_
      : ::ssa::AddressTricore::default_instance();
}
inline ::ssa::AddressTricore* Constant::mutable_address_tricore() {
  if (!has_address_tricore()) {
    clear_content();
    set_has_address_tricore();
    content_.address_tricore_ = new ::ssa::AddressTricore;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Constant.address_tricore)
  return content_.address_tricore_;
}
inline ::ssa::AddressTricore* Constant::release_address_tricore() {
  // @@protoc_insertion_point(field_release:ssa.Constant.address_tricore)
  if (has_address_tricore()) {
    clear_has_content();
    ::ssa::AddressTricore* temp = content_.address_tricore_;
    content_.address_tricore_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Constant::set_allocated_address_tricore(::ssa::AddressTricore* address_tricore) {
  clear_content();
  if (address_tricore) {
    set_has_address_tricore();
    content_.address_tricore_ = address_tricore;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Constant.address_tricore)
}

// optional .ssa.AddressX64 address_x64 = 4;
inline bool Constant::has_address_x64() const {
  return content_case() == kAddressX64;
}
inline void Constant::set_has_address_x64() {
  _oneof_case_[0] = kAddressX64;
}
inline void Constant::clear_address_x64() {
  if (has_address_x64()) {
    delete content_.address_x64_;
    clear_has_content();
  }
}
inline  const ::ssa::AddressX64& Constant::address_x64() const {
  // @@protoc_insertion_point(field_get:ssa.Constant.address_x64)
  return has_address_x64()
      ? *content_.address_x64_
      : ::ssa::AddressX64::default_instance();
}
inline ::ssa::AddressX64* Constant::mutable_address_x64() {
  if (!has_address_x64()) {
    clear_content();
    set_has_address_x64();
    content_.address_x64_ = new ::ssa::AddressX64;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Constant.address_x64)
  return content_.address_x64_;
}
inline ::ssa::AddressX64* Constant::release_address_x64() {
  // @@protoc_insertion_point(field_release:ssa.Constant.address_x64)
  if (has_address_x64()) {
    clear_has_content();
    ::ssa::AddressX64* temp = content_.address_x64_;
    content_.address_x64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Constant::set_allocated_address_x64(::ssa::AddressX64* address_x64) {
  clear_content();
  if (address_x64) {
    set_has_address_x64();
    content_.address_x64_ = address_x64;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Constant.address_x64)
}

inline bool Constant::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void Constant::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline Constant::ContentCase Constant::content_case() const {
  return Constant::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MemoryX64

// optional .ssa.Register base = 1;
inline bool MemoryX64::has_base() const {
  return !_is_default_instance_ && base_ != NULL;
}
inline void MemoryX64::clear_base() {
  if (GetArenaNoVirtual() == NULL && base_ != NULL) delete base_;
  base_ = NULL;
}
inline const ::ssa::Register& MemoryX64::base() const {
  // @@protoc_insertion_point(field_get:ssa.MemoryX64.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::ssa::Register* MemoryX64::mutable_base() {
  
  if (base_ == NULL) {
    base_ = new ::ssa::Register;
  }
  // @@protoc_insertion_point(field_mutable:ssa.MemoryX64.base)
  return base_;
}
inline ::ssa::Register* MemoryX64::release_base() {
  // @@protoc_insertion_point(field_release:ssa.MemoryX64.base)
  
  ::ssa::Register* temp = base_;
  base_ = NULL;
  return temp;
}
inline void MemoryX64::set_allocated_base(::ssa::Register* base) {
  delete base_;
  base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.MemoryX64.base)
}

// optional .ssa.Constant offset = 2;
inline bool MemoryX64::has_offset() const {
  return !_is_default_instance_ && offset_ != NULL;
}
inline void MemoryX64::clear_offset() {
  if (GetArenaNoVirtual() == NULL && offset_ != NULL) delete offset_;
  offset_ = NULL;
}
inline const ::ssa::Constant& MemoryX64::offset() const {
  // @@protoc_insertion_point(field_get:ssa.MemoryX64.offset)
  return offset_ != NULL ? *offset_ : *default_instance_->offset_;
}
inline ::ssa::Constant* MemoryX64::mutable_offset() {
  
  if (offset_ == NULL) {
    offset_ = new ::ssa::Constant;
  }
  // @@protoc_insertion_point(field_mutable:ssa.MemoryX64.offset)
  return offset_;
}
inline ::ssa::Constant* MemoryX64::release_offset() {
  // @@protoc_insertion_point(field_release:ssa.MemoryX64.offset)
  
  ::ssa::Constant* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline void MemoryX64::set_allocated_offset(::ssa::Constant* offset) {
  delete offset_;
  offset_ = offset;
  if (offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.MemoryX64.offset)
}

// optional .ssa.AccessType access_type = 3;
inline void MemoryX64::clear_access_type() {
  access_type_ = 0;
}
inline ::ssa::AccessType MemoryX64::access_type() const {
  // @@protoc_insertion_point(field_get:ssa.MemoryX64.access_type)
  return static_cast< ::ssa::AccessType >(access_type_);
}
inline void MemoryX64::set_access_type(::ssa::AccessType value) {
  
  access_type_ = value;
  // @@protoc_insertion_point(field_set:ssa.MemoryX64.access_type)
}

// optional .ssa.Register index = 4;
inline bool MemoryX64::has_index() const {
  return !_is_default_instance_ && index_ != NULL;
}
inline void MemoryX64::clear_index() {
  if (GetArenaNoVirtual() == NULL && index_ != NULL) delete index_;
  index_ = NULL;
}
inline const ::ssa::Register& MemoryX64::index() const {
  // @@protoc_insertion_point(field_get:ssa.MemoryX64.index)
  return index_ != NULL ? *index_ : *default_instance_->index_;
}
inline ::ssa::Register* MemoryX64::mutable_index() {
  
  if (index_ == NULL) {
    index_ = new ::ssa::Register;
  }
  // @@protoc_insertion_point(field_mutable:ssa.MemoryX64.index)
  return index_;
}
inline ::ssa::Register* MemoryX64::release_index() {
  // @@protoc_insertion_point(field_release:ssa.MemoryX64.index)
  
  ::ssa::Register* temp = index_;
  index_ = NULL;
  return temp;
}
inline void MemoryX64::set_allocated_index(::ssa::Register* index) {
  delete index_;
  index_ = index;
  if (index) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.MemoryX64.index)
}

// optional .ssa.Constant index_factor = 5;
inline bool MemoryX64::has_index_factor() const {
  return !_is_default_instance_ && index_factor_ != NULL;
}
inline void MemoryX64::clear_index_factor() {
  if (GetArenaNoVirtual() == NULL && index_factor_ != NULL) delete index_factor_;
  index_factor_ = NULL;
}
inline const ::ssa::Constant& MemoryX64::index_factor() const {
  // @@protoc_insertion_point(field_get:ssa.MemoryX64.index_factor)
  return index_factor_ != NULL ? *index_factor_ : *default_instance_->index_factor_;
}
inline ::ssa::Constant* MemoryX64::mutable_index_factor() {
  
  if (index_factor_ == NULL) {
    index_factor_ = new ::ssa::Constant;
  }
  // @@protoc_insertion_point(field_mutable:ssa.MemoryX64.index_factor)
  return index_factor_;
}
inline ::ssa::Constant* MemoryX64::release_index_factor() {
  // @@protoc_insertion_point(field_release:ssa.MemoryX64.index_factor)
  
  ::ssa::Constant* temp = index_factor_;
  index_factor_ = NULL;
  return temp;
}
inline void MemoryX64::set_allocated_index_factor(::ssa::Constant* index_factor) {
  delete index_factor_;
  index_factor_ = index_factor;
  if (index_factor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.MemoryX64.index_factor)
}

// -------------------------------------------------------------------

// MemoryTricore

// optional .ssa.Register base = 1;
inline bool MemoryTricore::has_base() const {
  return !_is_default_instance_ && base_ != NULL;
}
inline void MemoryTricore::clear_base() {
  if (GetArenaNoVirtual() == NULL && base_ != NULL) delete base_;
  base_ = NULL;
}
inline const ::ssa::Register& MemoryTricore::base() const {
  // @@protoc_insertion_point(field_get:ssa.MemoryTricore.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::ssa::Register* MemoryTricore::mutable_base() {
  
  if (base_ == NULL) {
    base_ = new ::ssa::Register;
  }
  // @@protoc_insertion_point(field_mutable:ssa.MemoryTricore.base)
  return base_;
}
inline ::ssa::Register* MemoryTricore::release_base() {
  // @@protoc_insertion_point(field_release:ssa.MemoryTricore.base)
  
  ::ssa::Register* temp = base_;
  base_ = NULL;
  return temp;
}
inline void MemoryTricore::set_allocated_base(::ssa::Register* base) {
  delete base_;
  base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.MemoryTricore.base)
}

// optional .ssa.Constant offset = 2;
inline bool MemoryTricore::has_offset() const {
  return !_is_default_instance_ && offset_ != NULL;
}
inline void MemoryTricore::clear_offset() {
  if (GetArenaNoVirtual() == NULL && offset_ != NULL) delete offset_;
  offset_ = NULL;
}
inline const ::ssa::Constant& MemoryTricore::offset() const {
  // @@protoc_insertion_point(field_get:ssa.MemoryTricore.offset)
  return offset_ != NULL ? *offset_ : *default_instance_->offset_;
}
inline ::ssa::Constant* MemoryTricore::mutable_offset() {
  
  if (offset_ == NULL) {
    offset_ = new ::ssa::Constant;
  }
  // @@protoc_insertion_point(field_mutable:ssa.MemoryTricore.offset)
  return offset_;
}
inline ::ssa::Constant* MemoryTricore::release_offset() {
  // @@protoc_insertion_point(field_release:ssa.MemoryTricore.offset)
  
  ::ssa::Constant* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline void MemoryTricore::set_allocated_offset(::ssa::Constant* offset) {
  delete offset_;
  offset_ = offset;
  if (offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.MemoryTricore.offset)
}

// optional .ssa.AccessType access_type = 3;
inline void MemoryTricore::clear_access_type() {
  access_type_ = 0;
}
inline ::ssa::AccessType MemoryTricore::access_type() const {
  // @@protoc_insertion_point(field_get:ssa.MemoryTricore.access_type)
  return static_cast< ::ssa::AccessType >(access_type_);
}
inline void MemoryTricore::set_access_type(::ssa::AccessType value) {
  
  access_type_ = value;
  // @@protoc_insertion_point(field_set:ssa.MemoryTricore.access_type)
}

// optional bool pre_increment = 4;
inline void MemoryTricore::clear_pre_increment() {
  pre_increment_ = false;
}
inline bool MemoryTricore::pre_increment() const {
  // @@protoc_insertion_point(field_get:ssa.MemoryTricore.pre_increment)
  return pre_increment_;
}
inline void MemoryTricore::set_pre_increment(bool value) {
  
  pre_increment_ = value;
  // @@protoc_insertion_point(field_set:ssa.MemoryTricore.pre_increment)
}

// optional bool post_increment = 5;
inline void MemoryTricore::clear_post_increment() {
  post_increment_ = false;
}
inline bool MemoryTricore::post_increment() const {
  // @@protoc_insertion_point(field_get:ssa.MemoryTricore.post_increment)
  return post_increment_;
}
inline void MemoryTricore::set_post_increment(bool value) {
  
  post_increment_ = value;
  // @@protoc_insertion_point(field_set:ssa.MemoryTricore.post_increment)
}

// -------------------------------------------------------------------

// Memory

// optional .ssa.MemoryX64 memory_x64 = 1;
inline bool Memory::has_memory_x64() const {
  return content_case() == kMemoryX64;
}
inline void Memory::set_has_memory_x64() {
  _oneof_case_[0] = kMemoryX64;
}
inline void Memory::clear_memory_x64() {
  if (has_memory_x64()) {
    delete content_.memory_x64_;
    clear_has_content();
  }
}
inline  const ::ssa::MemoryX64& Memory::memory_x64() const {
  // @@protoc_insertion_point(field_get:ssa.Memory.memory_x64)
  return has_memory_x64()
      ? *content_.memory_x64_
      : ::ssa::MemoryX64::default_instance();
}
inline ::ssa::MemoryX64* Memory::mutable_memory_x64() {
  if (!has_memory_x64()) {
    clear_content();
    set_has_memory_x64();
    content_.memory_x64_ = new ::ssa::MemoryX64;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Memory.memory_x64)
  return content_.memory_x64_;
}
inline ::ssa::MemoryX64* Memory::release_memory_x64() {
  // @@protoc_insertion_point(field_release:ssa.Memory.memory_x64)
  if (has_memory_x64()) {
    clear_has_content();
    ::ssa::MemoryX64* temp = content_.memory_x64_;
    content_.memory_x64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Memory::set_allocated_memory_x64(::ssa::MemoryX64* memory_x64) {
  clear_content();
  if (memory_x64) {
    set_has_memory_x64();
    content_.memory_x64_ = memory_x64;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Memory.memory_x64)
}

// optional .ssa.MemoryTricore memory_tricore = 2;
inline bool Memory::has_memory_tricore() const {
  return content_case() == kMemoryTricore;
}
inline void Memory::set_has_memory_tricore() {
  _oneof_case_[0] = kMemoryTricore;
}
inline void Memory::clear_memory_tricore() {
  if (has_memory_tricore()) {
    delete content_.memory_tricore_;
    clear_has_content();
  }
}
inline  const ::ssa::MemoryTricore& Memory::memory_tricore() const {
  // @@protoc_insertion_point(field_get:ssa.Memory.memory_tricore)
  return has_memory_tricore()
      ? *content_.memory_tricore_
      : ::ssa::MemoryTricore::default_instance();
}
inline ::ssa::MemoryTricore* Memory::mutable_memory_tricore() {
  if (!has_memory_tricore()) {
    clear_content();
    set_has_memory_tricore();
    content_.memory_tricore_ = new ::ssa::MemoryTricore;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Memory.memory_tricore)
  return content_.memory_tricore_;
}
inline ::ssa::MemoryTricore* Memory::release_memory_tricore() {
  // @@protoc_insertion_point(field_release:ssa.Memory.memory_tricore)
  if (has_memory_tricore()) {
    clear_has_content();
    ::ssa::MemoryTricore* temp = content_.memory_tricore_;
    content_.memory_tricore_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Memory::set_allocated_memory_tricore(::ssa::MemoryTricore* memory_tricore) {
  clear_content();
  if (memory_tricore) {
    set_has_memory_tricore();
    content_.memory_tricore_ = memory_tricore;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Memory.memory_tricore)
}

inline bool Memory::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void Memory::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline Memory::ContentCase Memory::content_case() const {
  return Memory::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CallingConvention

// optional fixed64 address = 1;
inline void CallingConvention::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CallingConvention::address() const {
  // @@protoc_insertion_point(field_get:ssa.CallingConvention.address)
  return address_;
}
inline void CallingConvention::set_address(::google::protobuf::uint64 value) {
  
  address_ = value;
  // @@protoc_insertion_point(field_set:ssa.CallingConvention.address)
}

// optional string mnemonic = 2;
inline void CallingConvention::clear_mnemonic() {
  mnemonic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CallingConvention::mnemonic() const {
  // @@protoc_insertion_point(field_get:ssa.CallingConvention.mnemonic)
  return mnemonic_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CallingConvention::set_mnemonic(const ::std::string& value) {
  
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ssa.CallingConvention.mnemonic)
}
inline void CallingConvention::set_mnemonic(const char* value) {
  
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ssa.CallingConvention.mnemonic)
}
inline void CallingConvention::set_mnemonic(const char* value, size_t size) {
  
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ssa.CallingConvention.mnemonic)
}
inline ::std::string* CallingConvention::mutable_mnemonic() {
  
  // @@protoc_insertion_point(field_mutable:ssa.CallingConvention.mnemonic)
  return mnemonic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CallingConvention::release_mnemonic() {
  // @@protoc_insertion_point(field_release:ssa.CallingConvention.mnemonic)
  
  return mnemonic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CallingConvention::set_allocated_mnemonic(::std::string* mnemonic) {
  if (mnemonic != NULL) {
    
  } else {
    
  }
  mnemonic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mnemonic);
  // @@protoc_insertion_point(field_set_allocated:ssa.CallingConvention.mnemonic)
}

// repeated .ssa.Operand operands = 3;
inline int CallingConvention::operands_size() const {
  return operands_.size();
}
inline void CallingConvention::clear_operands() {
  operands_.Clear();
}
inline const ::ssa::Operand& CallingConvention::operands(int index) const {
  // @@protoc_insertion_point(field_get:ssa.CallingConvention.operands)
  return operands_.Get(index);
}
inline ::ssa::Operand* CallingConvention::mutable_operands(int index) {
  // @@protoc_insertion_point(field_mutable:ssa.CallingConvention.operands)
  return operands_.Mutable(index);
}
inline ::ssa::Operand* CallingConvention::add_operands() {
  // @@protoc_insertion_point(field_add:ssa.CallingConvention.operands)
  return operands_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ssa::Operand >*
CallingConvention::mutable_operands() {
  // @@protoc_insertion_point(field_mutable_list:ssa.CallingConvention.operands)
  return &operands_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ssa::Operand >&
CallingConvention::operands() const {
  // @@protoc_insertion_point(field_list:ssa.CallingConvention.operands)
  return operands_;
}

// -------------------------------------------------------------------

// BaseInstruction

// optional fixed64 address = 1;
inline void BaseInstruction::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BaseInstruction::address() const {
  // @@protoc_insertion_point(field_get:ssa.BaseInstruction.address)
  return address_;
}
inline void BaseInstruction::set_address(::google::protobuf::uint64 value) {
  
  address_ = value;
  // @@protoc_insertion_point(field_set:ssa.BaseInstruction.address)
}

// optional string mnemonic = 2;
inline void BaseInstruction::clear_mnemonic() {
  mnemonic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BaseInstruction::mnemonic() const {
  // @@protoc_insertion_point(field_get:ssa.BaseInstruction.mnemonic)
  return mnemonic_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BaseInstruction::set_mnemonic(const ::std::string& value) {
  
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ssa.BaseInstruction.mnemonic)
}
inline void BaseInstruction::set_mnemonic(const char* value) {
  
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ssa.BaseInstruction.mnemonic)
}
inline void BaseInstruction::set_mnemonic(const char* value, size_t size) {
  
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ssa.BaseInstruction.mnemonic)
}
inline ::std::string* BaseInstruction::mutable_mnemonic() {
  
  // @@protoc_insertion_point(field_mutable:ssa.BaseInstruction.mnemonic)
  return mnemonic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BaseInstruction::release_mnemonic() {
  // @@protoc_insertion_point(field_release:ssa.BaseInstruction.mnemonic)
  
  return mnemonic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BaseInstruction::set_allocated_mnemonic(::std::string* mnemonic) {
  if (mnemonic != NULL) {
    
  } else {
    
  }
  mnemonic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mnemonic);
  // @@protoc_insertion_point(field_set_allocated:ssa.BaseInstruction.mnemonic)
}

// repeated .ssa.Operand operands = 3;
inline int BaseInstruction::operands_size() const {
  return operands_.size();
}
inline void BaseInstruction::clear_operands() {
  operands_.Clear();
}
inline const ::ssa::Operand& BaseInstruction::operands(int index) const {
  // @@protoc_insertion_point(field_get:ssa.BaseInstruction.operands)
  return operands_.Get(index);
}
inline ::ssa::Operand* BaseInstruction::mutable_operands(int index) {
  // @@protoc_insertion_point(field_mutable:ssa.BaseInstruction.operands)
  return operands_.Mutable(index);
}
inline ::ssa::Operand* BaseInstruction::add_operands() {
  // @@protoc_insertion_point(field_add:ssa.BaseInstruction.operands)
  return operands_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ssa::Operand >*
BaseInstruction::mutable_operands() {
  // @@protoc_insertion_point(field_mutable_list:ssa.BaseInstruction.operands)
  return &operands_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ssa::Operand >&
BaseInstruction::operands() const {
  // @@protoc_insertion_point(field_list:ssa.BaseInstruction.operands)
  return operands_;
}

// -------------------------------------------------------------------

// PhiNode

// optional fixed64 address = 1;
inline void PhiNode::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 PhiNode::address() const {
  // @@protoc_insertion_point(field_get:ssa.PhiNode.address)
  return address_;
}
inline void PhiNode::set_address(::google::protobuf::uint64 value) {
  
  address_ = value;
  // @@protoc_insertion_point(field_set:ssa.PhiNode.address)
}

// optional string mnemonic = 2;
inline void PhiNode::clear_mnemonic() {
  mnemonic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PhiNode::mnemonic() const {
  // @@protoc_insertion_point(field_get:ssa.PhiNode.mnemonic)
  return mnemonic_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PhiNode::set_mnemonic(const ::std::string& value) {
  
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ssa.PhiNode.mnemonic)
}
inline void PhiNode::set_mnemonic(const char* value) {
  
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ssa.PhiNode.mnemonic)
}
inline void PhiNode::set_mnemonic(const char* value, size_t size) {
  
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ssa.PhiNode.mnemonic)
}
inline ::std::string* PhiNode::mutable_mnemonic() {
  
  // @@protoc_insertion_point(field_mutable:ssa.PhiNode.mnemonic)
  return mnemonic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PhiNode::release_mnemonic() {
  // @@protoc_insertion_point(field_release:ssa.PhiNode.mnemonic)
  
  return mnemonic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PhiNode::set_allocated_mnemonic(::std::string* mnemonic) {
  if (mnemonic != NULL) {
    
  } else {
    
  }
  mnemonic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mnemonic);
  // @@protoc_insertion_point(field_set_allocated:ssa.PhiNode.mnemonic)
}

// repeated .ssa.Operand operands = 3;
inline int PhiNode::operands_size() const {
  return operands_.size();
}
inline void PhiNode::clear_operands() {
  operands_.Clear();
}
inline const ::ssa::Operand& PhiNode::operands(int index) const {
  // @@protoc_insertion_point(field_get:ssa.PhiNode.operands)
  return operands_.Get(index);
}
inline ::ssa::Operand* PhiNode::mutable_operands(int index) {
  // @@protoc_insertion_point(field_mutable:ssa.PhiNode.operands)
  return operands_.Mutable(index);
}
inline ::ssa::Operand* PhiNode::add_operands() {
  // @@protoc_insertion_point(field_add:ssa.PhiNode.operands)
  return operands_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ssa::Operand >*
PhiNode::mutable_operands() {
  // @@protoc_insertion_point(field_mutable_list:ssa.PhiNode.operands)
  return &operands_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ssa::Operand >&
PhiNode::operands() const {
  // @@protoc_insertion_point(field_list:ssa.PhiNode.operands)
  return operands_;
}

// -------------------------------------------------------------------

// Operand

// optional .ssa.Register register = 1;
inline bool Operand::has_register_() const {
  return content_case() == kRegister;
}
inline void Operand::set_has_register_() {
  _oneof_case_[0] = kRegister;
}
inline void Operand::clear_register_() {
  if (has_register_()) {
    delete content_.register__;
    clear_has_content();
  }
}
inline  const ::ssa::Register& Operand::register_() const {
  // @@protoc_insertion_point(field_get:ssa.Operand.register)
  return has_register_()
      ? *content_.register__
      : ::ssa::Register::default_instance();
}
inline ::ssa::Register* Operand::mutable_register_() {
  if (!has_register_()) {
    clear_content();
    set_has_register_();
    content_.register__ = new ::ssa::Register;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Operand.register)
  return content_.register__;
}
inline ::ssa::Register* Operand::release_register_() {
  // @@protoc_insertion_point(field_release:ssa.Operand.register)
  if (has_register_()) {
    clear_has_content();
    ::ssa::Register* temp = content_.register__;
    content_.register__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Operand::set_allocated_register_(::ssa::Register* register_) {
  clear_content();
  if (register_) {
    set_has_register_();
    content_.register__ = register_;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Operand.register)
}

// optional .ssa.Constant constant = 2;
inline bool Operand::has_constant() const {
  return content_case() == kConstant;
}
inline void Operand::set_has_constant() {
  _oneof_case_[0] = kConstant;
}
inline void Operand::clear_constant() {
  if (has_constant()) {
    delete content_.constant_;
    clear_has_content();
  }
}
inline  const ::ssa::Constant& Operand::constant() const {
  // @@protoc_insertion_point(field_get:ssa.Operand.constant)
  return has_constant()
      ? *content_.constant_
      : ::ssa::Constant::default_instance();
}
inline ::ssa::Constant* Operand::mutable_constant() {
  if (!has_constant()) {
    clear_content();
    set_has_constant();
    content_.constant_ = new ::ssa::Constant;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Operand.constant)
  return content_.constant_;
}
inline ::ssa::Constant* Operand::release_constant() {
  // @@protoc_insertion_point(field_release:ssa.Operand.constant)
  if (has_constant()) {
    clear_has_content();
    ::ssa::Constant* temp = content_.constant_;
    content_.constant_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Operand::set_allocated_constant(::ssa::Constant* constant) {
  clear_content();
  if (constant) {
    set_has_constant();
    content_.constant_ = constant;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Operand.constant)
}

// optional .ssa.Memory memory = 3;
inline bool Operand::has_memory() const {
  return content_case() == kMemory;
}
inline void Operand::set_has_memory() {
  _oneof_case_[0] = kMemory;
}
inline void Operand::clear_memory() {
  if (has_memory()) {
    delete content_.memory_;
    clear_has_content();
  }
}
inline  const ::ssa::Memory& Operand::memory() const {
  // @@protoc_insertion_point(field_get:ssa.Operand.memory)
  return has_memory()
      ? *content_.memory_
      : ::ssa::Memory::default_instance();
}
inline ::ssa::Memory* Operand::mutable_memory() {
  if (!has_memory()) {
    clear_content();
    set_has_memory();
    content_.memory_ = new ::ssa::Memory;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Operand.memory)
  return content_.memory_;
}
inline ::ssa::Memory* Operand::release_memory() {
  // @@protoc_insertion_point(field_release:ssa.Operand.memory)
  if (has_memory()) {
    clear_has_content();
    ::ssa::Memory* temp = content_.memory_;
    content_.memory_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Operand::set_allocated_memory(::ssa::Memory* memory) {
  clear_content();
  if (memory) {
    set_has_memory();
    content_.memory_ = memory;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Operand.memory)
}

inline bool Operand::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void Operand::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline Operand::ContentCase Operand::content_case() const {
  return Operand::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Instruction

// optional .ssa.CallingConvention calling_convention = 1;
inline bool Instruction::has_calling_convention() const {
  return content_case() == kCallingConvention;
}
inline void Instruction::set_has_calling_convention() {
  _oneof_case_[0] = kCallingConvention;
}
inline void Instruction::clear_calling_convention() {
  if (has_calling_convention()) {
    delete content_.calling_convention_;
    clear_has_content();
  }
}
inline  const ::ssa::CallingConvention& Instruction::calling_convention() const {
  // @@protoc_insertion_point(field_get:ssa.Instruction.calling_convention)
  return has_calling_convention()
      ? *content_.calling_convention_
      : ::ssa::CallingConvention::default_instance();
}
inline ::ssa::CallingConvention* Instruction::mutable_calling_convention() {
  if (!has_calling_convention()) {
    clear_content();
    set_has_calling_convention();
    content_.calling_convention_ = new ::ssa::CallingConvention;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Instruction.calling_convention)
  return content_.calling_convention_;
}
inline ::ssa::CallingConvention* Instruction::release_calling_convention() {
  // @@protoc_insertion_point(field_release:ssa.Instruction.calling_convention)
  if (has_calling_convention()) {
    clear_has_content();
    ::ssa::CallingConvention* temp = content_.calling_convention_;
    content_.calling_convention_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Instruction::set_allocated_calling_convention(::ssa::CallingConvention* calling_convention) {
  clear_content();
  if (calling_convention) {
    set_has_calling_convention();
    content_.calling_convention_ = calling_convention;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Instruction.calling_convention)
}

// optional .ssa.BaseInstruction instruction = 2;
inline bool Instruction::has_instruction() const {
  return content_case() == kInstruction;
}
inline void Instruction::set_has_instruction() {
  _oneof_case_[0] = kInstruction;
}
inline void Instruction::clear_instruction() {
  if (has_instruction()) {
    delete content_.instruction_;
    clear_has_content();
  }
}
inline  const ::ssa::BaseInstruction& Instruction::instruction() const {
  // @@protoc_insertion_point(field_get:ssa.Instruction.instruction)
  return has_instruction()
      ? *content_.instruction_
      : ::ssa::BaseInstruction::default_instance();
}
inline ::ssa::BaseInstruction* Instruction::mutable_instruction() {
  if (!has_instruction()) {
    clear_content();
    set_has_instruction();
    content_.instruction_ = new ::ssa::BaseInstruction;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Instruction.instruction)
  return content_.instruction_;
}
inline ::ssa::BaseInstruction* Instruction::release_instruction() {
  // @@protoc_insertion_point(field_release:ssa.Instruction.instruction)
  if (has_instruction()) {
    clear_has_content();
    ::ssa::BaseInstruction* temp = content_.instruction_;
    content_.instruction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Instruction::set_allocated_instruction(::ssa::BaseInstruction* instruction) {
  clear_content();
  if (instruction) {
    set_has_instruction();
    content_.instruction_ = instruction;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Instruction.instruction)
}

// optional .ssa.PhiNode phi_node = 3;
inline bool Instruction::has_phi_node() const {
  return content_case() == kPhiNode;
}
inline void Instruction::set_has_phi_node() {
  _oneof_case_[0] = kPhiNode;
}
inline void Instruction::clear_phi_node() {
  if (has_phi_node()) {
    delete content_.phi_node_;
    clear_has_content();
  }
}
inline  const ::ssa::PhiNode& Instruction::phi_node() const {
  // @@protoc_insertion_point(field_get:ssa.Instruction.phi_node)
  return has_phi_node()
      ? *content_.phi_node_
      : ::ssa::PhiNode::default_instance();
}
inline ::ssa::PhiNode* Instruction::mutable_phi_node() {
  if (!has_phi_node()) {
    clear_content();
    set_has_phi_node();
    content_.phi_node_ = new ::ssa::PhiNode;
  }
  // @@protoc_insertion_point(field_mutable:ssa.Instruction.phi_node)
  return content_.phi_node_;
}
inline ::ssa::PhiNode* Instruction::release_phi_node() {
  // @@protoc_insertion_point(field_release:ssa.Instruction.phi_node)
  if (has_phi_node()) {
    clear_has_content();
    ::ssa::PhiNode* temp = content_.phi_node_;
    content_.phi_node_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Instruction::set_allocated_phi_node(::ssa::PhiNode* phi_node) {
  clear_content();
  if (phi_node) {
    set_has_phi_node();
    content_.phi_node_ = phi_node;
  }
  // @@protoc_insertion_point(field_set_allocated:ssa.Instruction.phi_node)
}

inline bool Instruction::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void Instruction::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline Instruction::ContentCase Instruction::content_case() const {
  return Instruction::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BasicBlock

// optional fixed64 address = 1;
inline void BasicBlock::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BasicBlock::address() const {
  // @@protoc_insertion_point(field_get:ssa.BasicBlock.address)
  return address_;
}
inline void BasicBlock::set_address(::google::protobuf::uint64 value) {
  
  address_ = value;
  // @@protoc_insertion_point(field_set:ssa.BasicBlock.address)
}

// optional fixed64 end = 2;
inline void BasicBlock::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BasicBlock::end() const {
  // @@protoc_insertion_point(field_get:ssa.BasicBlock.end)
  return end_;
}
inline void BasicBlock::set_end(::google::protobuf::uint64 value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:ssa.BasicBlock.end)
}

// repeated .ssa.Instruction instructions = 3;
inline int BasicBlock::instructions_size() const {
  return instructions_.size();
}
inline void BasicBlock::clear_instructions() {
  instructions_.Clear();
}
inline const ::ssa::Instruction& BasicBlock::instructions(int index) const {
  // @@protoc_insertion_point(field_get:ssa.BasicBlock.instructions)
  return instructions_.Get(index);
}
inline ::ssa::Instruction* BasicBlock::mutable_instructions(int index) {
  // @@protoc_insertion_point(field_mutable:ssa.BasicBlock.instructions)
  return instructions_.Mutable(index);
}
inline ::ssa::Instruction* BasicBlock::add_instructions() {
  // @@protoc_insertion_point(field_add:ssa.BasicBlock.instructions)
  return instructions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ssa::Instruction >*
BasicBlock::mutable_instructions() {
  // @@protoc_insertion_point(field_mutable_list:ssa.BasicBlock.instructions)
  return &instructions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ssa::Instruction >&
BasicBlock::instructions() const {
  // @@protoc_insertion_point(field_list:ssa.BasicBlock.instructions)
  return instructions_;
}

// repeated fixed64 predecessors = 4;
inline int BasicBlock::predecessors_size() const {
  return predecessors_.size();
}
inline void BasicBlock::clear_predecessors() {
  predecessors_.Clear();
}
inline ::google::protobuf::uint64 BasicBlock::predecessors(int index) const {
  // @@protoc_insertion_point(field_get:ssa.BasicBlock.predecessors)
  return predecessors_.Get(index);
}
inline void BasicBlock::set_predecessors(int index, ::google::protobuf::uint64 value) {
  predecessors_.Set(index, value);
  // @@protoc_insertion_point(field_set:ssa.BasicBlock.predecessors)
}
inline void BasicBlock::add_predecessors(::google::protobuf::uint64 value) {
  predecessors_.Add(value);
  // @@protoc_insertion_point(field_add:ssa.BasicBlock.predecessors)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
BasicBlock::predecessors() const {
  // @@protoc_insertion_point(field_list:ssa.BasicBlock.predecessors)
  return predecessors_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
BasicBlock::mutable_predecessors() {
  // @@protoc_insertion_point(field_mutable_list:ssa.BasicBlock.predecessors)
  return &predecessors_;
}

// repeated fixed64 successors = 5;
inline int BasicBlock::successors_size() const {
  return successors_.size();
}
inline void BasicBlock::clear_successors() {
  successors_.Clear();
}
inline ::google::protobuf::uint64 BasicBlock::successors(int index) const {
  // @@protoc_insertion_point(field_get:ssa.BasicBlock.successors)
  return successors_.Get(index);
}
inline void BasicBlock::set_successors(int index, ::google::protobuf::uint64 value) {
  successors_.Set(index, value);
  // @@protoc_insertion_point(field_set:ssa.BasicBlock.successors)
}
inline void BasicBlock::add_successors(::google::protobuf::uint64 value) {
  successors_.Add(value);
  // @@protoc_insertion_point(field_add:ssa.BasicBlock.successors)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
BasicBlock::successors() const {
  // @@protoc_insertion_point(field_list:ssa.BasicBlock.successors)
  return successors_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
BasicBlock::mutable_successors() {
  // @@protoc_insertion_point(field_mutable_list:ssa.BasicBlock.successors)
  return &successors_;
}

// -------------------------------------------------------------------

// Function

// optional fixed64 address = 1;
inline void Function::clear_address() {
  address_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Function::address() const {
  // @@protoc_insertion_point(field_get:ssa.Function.address)
  return address_;
}
inline void Function::set_address(::google::protobuf::uint64 value) {
  
  address_ = value;
  // @@protoc_insertion_point(field_set:ssa.Function.address)
}

// repeated .ssa.BasicBlock basic_blocks = 2;
inline int Function::basic_blocks_size() const {
  return basic_blocks_.size();
}
inline void Function::clear_basic_blocks() {
  basic_blocks_.Clear();
}
inline const ::ssa::BasicBlock& Function::basic_blocks(int index) const {
  // @@protoc_insertion_point(field_get:ssa.Function.basic_blocks)
  return basic_blocks_.Get(index);
}
inline ::ssa::BasicBlock* Function::mutable_basic_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:ssa.Function.basic_blocks)
  return basic_blocks_.Mutable(index);
}
inline ::ssa::BasicBlock* Function::add_basic_blocks() {
  // @@protoc_insertion_point(field_add:ssa.Function.basic_blocks)
  return basic_blocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ssa::BasicBlock >*
Function::mutable_basic_blocks() {
  // @@protoc_insertion_point(field_mutable_list:ssa.Function.basic_blocks)
  return &basic_blocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ssa::BasicBlock >&
Function::basic_blocks() const {
  // @@protoc_insertion_point(field_list:ssa.Function.basic_blocks)
  return basic_blocks_;
}

// -------------------------------------------------------------------

// Functions

// repeated .ssa.Function functions = 1;
inline int Functions::functions_size() const {
  return functions_.size();
}
inline void Functions::clear_functions() {
  functions_.Clear();
}
inline const ::ssa::Function& Functions::functions(int index) const {
  // @@protoc_insertion_point(field_get:ssa.Functions.functions)
  return functions_.Get(index);
}
inline ::ssa::Function* Functions::mutable_functions(int index) {
  // @@protoc_insertion_point(field_mutable:ssa.Functions.functions)
  return functions_.Mutable(index);
}
inline ::ssa::Function* Functions::add_functions() {
  // @@protoc_insertion_point(field_add:ssa.Functions.functions)
  return functions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ssa::Function >*
Functions::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_list:ssa.Functions.functions)
  return &functions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ssa::Function >&
Functions::functions() const {
  // @@protoc_insertion_point(field_list:ssa.Functions.functions)
  return functions_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ssa

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ssa::AccessType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ssa::AccessType>() {
  return ::ssa::AccessType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ssa_5fexport_2eproto__INCLUDED
